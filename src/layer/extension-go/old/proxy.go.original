// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: MIT-0

// Read about Lambda Runtime API here
// https://docs.aws.amazon.com/lambda/latest/dg/runtimes-api.html

package proxy

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"strings"

	"github.com/go-chi/chi/v5"
)

const (
	printPrefix     = "[LiveLambdaProxy:Proxy]"
)

var (
	awsLambdaRuntimeAPI string
	httpClient = &http.Client{}
	// This will be set by main.go to the instance of our RuntimeAPIProxy
	// allowing AppSync interactions from proxy handlers.
	AppSyncProxyHelper interface {
		HandleAppSyncSubscriptionForRequest(ctx context.Context, requestID string)
		HandleAppSyncPublishForResponse(ctx context.Context, requestID string, responseBody []byte)
	}
)

// SetAppSyncHelper allows main to inject the AppSync interaction logic.
func SetAppSyncHelper(helper interface{
	HandleAppSyncSubscriptionForRequest(ctx context.Context, requestID string)
	HandleAppSyncPublishForResponse(ctx context.Context, requestID string, responseBody []byte)
}) {
	AppSyncProxyHelper = helper
}

// StartProxy initializes and starts the HTTP proxy server.
func StartProxy(actualRuntimeAPI string, port int) {
	log.Println(printPrefix, "Starting proxy server on port", port, "targeting", actualRuntimeAPI)
	awsLambdaRuntimeAPI = actualRuntimeAPI

	r := chi.NewRouter()
	r.Use(simpleLogger)

	// Lambda Runtime API endpoints
	r.Get("/2018-06-01/runtime/invocation/next", handleNext)
	r.Post("/2018-06-01/runtime/invocation/{requestId}/response", handleResponse)
	r.Post("/2018-06-01/runtime/init/error", handleInitError)
	r.Post("/2018-06-01/runtime/invocation/{requestId}/error", handleInvokeError)

	r.NotFound(handleError)
	r.MethodNotAllowed(handleError)

	server := &http.Server{
		Addr:    fmt.Sprintf(":%d", port),
		Handler: r,
	}

	go func() {
		err := server.ListenAndServe()
		if err != nil && err != http.ErrServerClosed {
			log.Printf("%s proxy server ListenAndServe error: %v", printPrefix, err)
		}
		log.Println(printPrefix, "Proxy server goroutine finished.")
	}()
	log.Println(printPrefix, "Proxy Server Started")
}

func handleNext(w http.ResponseWriter, r *http.Request) {
	log.Println(printPrefix, "GET /next")

	url := fmt.Sprintf("http://%s/2018-06-01/runtime/invocation/next", awsLambdaRuntimeAPI)

	resp, err := forwardRequest("GET", url, r.Body, r.Header)
	if err != nil {
		http.Error(w, fmt.Sprintf("Error forwarding /next request: %v", err), http.StatusInternalServerError)
		return
	}
	defer resp.Body.Close()

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		http.Error(w, fmt.Sprintf("Error reading /next response body: %v", err), http.StatusInternalServerError)
		return
	}

	// Extract request ID for AppSync interactions
	requestID := resp.Header.Get("Lambda-Runtime-Aws-Request-Id")

	modifiedBody, modifiedHeaders := processRequest(r.Context(), requestID, bodyBytes, resp.Header)

	copyHeaders(modifiedHeaders, w.Header())
	w.WriteHeader(resp.StatusCode)
	_, err = w.Write(modifiedBody)
	if err != nil {
		log.Printf("%s Error writing /next response to client: %v", printPrefix, err)
	}
	log.Println(printPrefix, "GET /next completed")
}

func handleResponse(w http.ResponseWriter, r *http.Request) {
	requestID := chi.URLParam(r, "requestId")
	log.Println(printPrefix, "POST /response for requestID:", requestID)

	bodyBytes, err := io.ReadAll(r.Body)
	if err != nil {
		http.Error(w, fmt.Sprintf("Error reading /response request body: %v", err), http.StatusBadRequest)
		return
	}

	modifiedBody, modifiedHeaders := processResponse(r.Context(), requestID, bodyBytes, r.Header)

	url := fmt.Sprintf("http://%s/2018-06-01/runtime/invocation/%s/response", awsLambdaRuntimeAPI, requestID)
	bodyBuffer := io.NopCloser(bytes.NewReader(modifiedBody))

	forwardAndRespond(w, "POST", url, bodyBuffer, modifiedHeaders)
	log.Println(printPrefix, "POST /response completed for requestID:", requestID)
}

func handleInitError(w http.ResponseWriter, r *http.Request) {
	log.Println(printPrefix, "POST /init/error")
	url := fmt.Sprintf("http://%s/2018-06-01/runtime/init/error", awsLambdaRuntimeAPI)
	forwardAndRespond(w, "POST", url, r.Body, r.Header)
	log.Println(printPrefix, "POST /init/error completed")
}

func handleInvokeError(w http.ResponseWriter, r *http.Request) {
	requestID := chi.URLParam(r, "requestId")
	log.Println(printPrefix, "POST /error for requestID:", requestID)
	url := fmt.Sprintf("http://%s/2018-06-01/runtime/invocation/%s/error", awsLambdaRuntimeAPI, requestID)
	forwardAndRespond(w, "POST", url, r.Body, r.Header)
	log.Println(printPrefix, "POST /error completed for requestID:", requestID)
}

func forwardAndRespond(w http.ResponseWriter, method string, url string, body io.ReadCloser, headers http.Header) {
	resp, err := forwardRequest(method, url, body, headers)
	if err != nil {
		http.Error(w, fmt.Sprintf("Error forwarding %s request to %s: %v", method, url, err), http.StatusInternalServerError)
		return
	}
	defer resp.Body.Close()

	respBodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		http.Error(w, fmt.Sprintf("Error reading response body from %s: %v", url, err), http.StatusInternalServerError)
		return
	}

	copyHeaders(resp.Header, w.Header())
	w.WriteHeader(resp.StatusCode)
	_, err = w.Write(respBodyBytes)
	if err != nil {
		log.Printf("%s Error writing response to client: %v", printPrefix, err)
	}
}

func handleError(w http.ResponseWriter, r *http.Request) {
	log.Printf("%s Path or Protocol Error: %s %s", printPrefix, r.Method, r.URL.Path)
	http.Error(w, http.StatusText(http.StatusNotFound), http.StatusNotFound)
}

func copyHeaders(source http.Header, dest http.Header) {
	for key, values := range source {
		dest[key] = values
	}
}

func forwardRequest(method string, url string, body io.Reader, headers http.Header) (*http.Response, error) {
	req, err := http.NewRequest(method, url, body)
	if err != nil {
		log.Printf("%s Error creating %s request to %s: %v", printPrefix, method, url, err)
		return nil, err
	}
	copyHeaders(headers, req.Header)

	// Ensure Host header is set correctly if it's being proxied.
	// For Lambda Runtime API, it's a local endpoint, so default behavior is likely fine.

	resp, err := httpClient.Do(req)
	if err != nil {
		log.Printf("%s Error sending %s request to %s: %v", printPrefix, method, url, err)
		return nil, err
	}
	return resp, nil
}

func simpleLogger(next http.Handler) http.Handler {
	fn := func(w http.ResponseWriter, r *http.Request) {
		log.Printf("%s %s %s", printPrefix, r.Method, r.URL.Path)
		next.ServeHTTP(w, r)
	}
	return http.HandlerFunc(fn)
}

// processRequest can modify the request body or headers before sending to the Runtime API (for /next)
// or before sending back to the function (if we were proxying the other way).
// For /next, this is modifying the response *from* the Runtime API *before* it goes to the function.
func processRequest(ctx context.Context, requestID string, body []byte, headers http.Header) ([]byte, http.Header) {
	log.Printf("%s processRequest for requestID: %s", printPrefix, requestID)
	// Placeholder for AppSync subscription logic
	if AppSyncProxyHelper != nil && requestID != "" {
		AppSyncProxyHelper.HandleAppSyncSubscriptionForRequest(ctx, requestID)
	}

	// Example modification (from sample)
	jsonBody, err := unmarshalBody(body)
	if err == nil {
		jsonBody["LiveLambdaRequestModified"] = true
		newBody, marshalErr := json.Marshal(jsonBody)
		if marshalErr == nil {
			return newBody, headers
		}
		log.Printf("%s Error marshalling modified request body: %v", printPrefix, marshalErr)
	}
	return body, headers // Return original on error
}

// processResponse can modify the response body or headers from the function before sending to the Runtime API.
func processResponse(ctx context.Context, requestID string, body []byte, headers http.Header) ([]byte, http.Header) {
	log.Printf("%s processResponse for requestID: %s", printPrefix, requestID)
	// Placeholder for AppSync publishing logic
	if AppSyncProxyHelper != nil && requestID != "" {
		AppSyncProxyHelper.HandleAppSyncPublishForResponse(ctx, requestID, body)
	}

	// Example modification (from sample)
	jsonBody, err := unmarshalBody(body)
	if err == nil {
		jsonBody["LiveLambdaResponseModified"] = true
		newBody, marshalErr := json.Marshal(jsonBody)
		if marshalErr == nil {
			return newBody, headers
		}
		log.Printf("%s Error marshalling modified response body: %v", printPrefix, marshalErr)
	}
	return body, headers // Return original on error
}

func unmarshalBody(body []byte) (map[string]interface{}, error) {
	var temp = make(map[string]interface{})
	err := json.Unmarshal(body, &temp)
	if err != nil {
		// It's common for response bodies to not be JSON, so don't be too noisy.
		// log.Printf("%s failed to unmarshal response body: %v", printPrefix, err)
		return nil, err
	}
	return temp, nil
}
